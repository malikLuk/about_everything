/**
 *
 *                                                 Загрузка классов в Java. Теория.
 * Одной из основных особенностей платформы Java является модель динамической загрузки классов, которая позволяет загружать
 * исполняемый кодв JRE не перезагружая основное приложение.
 * Любой класс (это экземпляр java.lang.Class в среде и .class файлы в файловой системе), используемый в среде исполнения
 * был так или иначе загружен каким-либо загрузчиком в Java. Для того, чтобы узнать, каким именно загрузчиком был загружен
 * класс A, нужно воспользоваться методом A.class.getClassLoader();
 * Классы загружаются по мере надобности, за небольшим исключением. Некоторые базовые классы из rt.jar (java.lang.* в
 * частности) загружаются при старте приложения. Классы расширений ($JAVA_HOME/lib/ext), пользовательские и большинство
 * системных классов загружаются по мере их использования.
 * Виды загрузчиков.
 * Различают три вида загрузчиков в Java. Это Базовый загрузчик(bootstrap), Системный загрузчик(System Classloader),
 * загрузчик расширений (Extension Classloader).
 * Bootstrap - реализован на уровне JVM и не имеет обратной связи со средой исполнения, то есть из jre до него не достучаться.
 * Данный загрузчик загружает классы из директории $JAVA_HOME/lib. В общем, попытка получить у загрузчика классы из
 * семейства пакетов java.* всегда закончатся null'ом, потому что, как уже говорилось, из jre до него не достучаться.
 * Однако, управлять Базовым загрузчиком можно с помощью ключа -Xbootclasspath, который позволяет переопределять набор
 * базовых классов.
 * System Classloader - Системный загрузчик, реализованный на уровне JRE. В Sun JRE - это класс sun.misc.Launcher$AppClassLoader,
 * в чем мы можем убедиться, запустив код из метода main(String[] args). Этим загрузчиком загружаются классы приложения,
 * то есть классы из CLASSPATH. Управлять Системным загрузчиком можно с помощью ключа -classpath или системной опцией
 * java.class.path.
 * Extension Classloader - Загрузчик расширений. Данный загрузчик загружает классы из директории $JAVA_HOME/lib/ext. В
 * Sun JRE - это класс sun.misc.Launcher$ExtClassLoader. Управлять загрузкой расширений можно с помощью системной опции
 * java.ext.dirs.
 * Различают текущий загрузчик (Current Classloader) и загрузчик контекста (Context Classloader).
 * Current Classloader - это загрузчик класса, код которого в данный момент исполняется. Текущий загрузчик используется
 * по умолчанию для загрузки классов в процессе исполнения.
 * Context Classloader - загрузчик контекста текущего потока. Получить и установить данный загрузчик можно с помощью
 * методов Thread.getContextClassLoader() / Thread.setContextClassLoader(). Загрузчик констекста устанавливается
 * автоматически для каждого нового потока.
 * Модель делегирования загрузки.
 * Загрузчики классов образуют иерархию. Корневым является базовый (bootstrap) - у него предка нет. Все остальные
 * загрузчики при инициализации инстанциируют ссылку на родительский загрузчик. Право загрузки класса рекурсивно делегируется
 * от самого нижнего загрузчика в иерархии к самому верхнему. Такой подход позволяет загружать классы тем загрузчиком,
 * который максимально близко находится к базовому. Так достигается максимальная область видимости классов.
 *
 * Пример загрузки класса Student
 * 1) Системный загрузчик попытается поискать в кеше класс Student.
 *  _1.1) Если класс найден, загрузка окончена.
 *  _1.2) Если класс не найден, загрузка делегируется загрузчику расширений.
 * 2) Загрузчик расширений попытается поискать в кеше класс Student.
 *  _2.1) Если класс найден, загрузка окончена.
 *  _2.2) Если класс не найден, загрузка делегируется базовому загрузчику.
 * 3) Базовый загрузчик попытается поискать в кеше класс Student.
 *  _3.1) Если класс найден, загрузка окончена.
 *  _3.2) Если класс не найден, базовый загрузчик попытается его загрузить.
 *   __3.2.1) Если загрузка прошла успешно, она закончена ;)
 *   __3.2.2) Иначе управление предается загрузчику раширений.
 *  _3.3) Загрузчик расширений пытается загрузить класс.
 *   __3.3.1) Если загрузка прошла успешно, она закончена ;)
 *   __3.3.2) Иначе управление предается системному загрузчику.
 *  _3.4) Системный загрузчик пытается загрузить класс.
 *   __3.4.1) Если загрузка прошла успешно, она закончена ;)
 *   __3.4.2) Иначе генерируется исключение java.lang.ClassNotFoundException.
 * Если в системе присутствуют пользовательские загрузчики - они должны расширять java.lang.ClassLoasder и поддерживать
 * модель динамической загрузки.
 * Если запустить JVM с ключом -verbose:class, то можно увидеть в каком порядке загружаются классы.
 *
 * */


package classloader;

public class ClassLoaderHabr {

    public static void main(String[] args) {
        System.out.println(LoadedBy.class.getClassLoader());
        System.out.println(ClassLoaderHabr.class.getClassLoader());
        System.out.println(Object.class.getClassLoader());
    }

}

class LoadedBy {

}
