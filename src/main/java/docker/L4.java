/**
 *
 * Одной из сильных сторон Docker является кэширование, благодаря которому ускоряется сборка образов. При сборке образа,
 * Docker проходится по инструкциям из dockerfile'а, выполняя их по порядку сверху вниз. В процессе анализа инструкций,
 * Docker проверяет собственный кэш на наличие в нем образов, представляющих собой то, что получается на промежуточных
 * этапах сборки других образов. Если подобные образы удается найти, то система может ими воспользоваться, не тратя
 * время на их повторное создание.
 *
 *      - Кэширование можно отключить, передав ключ --no-cache=True команде docker build.
 *      - Если мы собираемся вносить изменения в инстуркции dockerfile, то каждый слой, созданный инструкциями, идущими
 *              после измененных, будет достаточно часто собираться повторно, без использования кэша. Для того, чтобы
 *              воспользоваться преимуществами кэширования, нужно помещать инстуркции, вероятность изменения которых
 *              высока, ближе к концу dockerfile'а.
 *      - Лучше объединять команды RUN apt-get update и apt-get install в цепочки для того, чтобы исключить проблемы,
 *              связанные с неправильным использованием кэша.
 *      - При использовании менеджера пакетов, типа pip вместе с файлом requirements.txt, в котором описаны нужные
 *              пакеты, лучше придерживаться нижеприведенной схемы. Все потому, что однажды закэшировавшись, Docker не
 *              проверяет обновленную начинку requirements.txt при следующих сборках, а смотрит просто на  факт наличия
 *              этого файла. Схема такая:
 *                  COPY requirements.txt /tmp/
 *                  RUN pip install -r /tmp/requirements.txt
 *                  COPY . /tmp/
 *
 * Многоступенчатая сборка образов.
 * В dockerfile, описывающем многоступенчатую сборку образа, используется несколько инструкций FROM. Создатель такого
 * образа может настроить выборочное копирование файлов, называемых артефактами сборки из одной ступени сборки в другую.
 * При этом появляется возможность избавиться от всего того, что в готовом образе не понадобится. Так можно уменьшить
 * размер готового образа. Вот как работает каждая инструкция FROM:
 *      - Она начинает новый шаг сборки.
 *      - Она не заивисит от того, что было создано на предыдущем шаге сборки.
 *      - Она может использовать базовый образ, отличающийся от того, который применялся на предыдущем шаге.
 * Примерно так выглядит многоступенчатая сборка:
 *  FROM golang:1.7.3 AS build
 *  WORKDIR /go/src/github.com/alexellis/href-counter/
 *  RUN go get -d -v golang.org/x/net/html
 *  COPY app.go .
 *  RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .
 *  FROM alpine:latest
 *  RUN apk --no-cache add ca-certificates
 *  WORKDIR /root/
 *  COPY --from=build /go/src/github.com/alexellis/href-counter/app .
 *  CMD ["./app"]
 *
 * Обратим внимание, что мы дали имя первой ступени сборки (AS build). К этмоу именованому этапу сборки мы обращаемся в
 * предпоследней строке "COPY --from=build /go/src/github.com/alexellis/href-counter/app .". Применение многоступенчатой
 * сборки имеет смысл, когда приходится создавать множество контейнеров для прод-окружение. Многоступенчатая сборка
 * позволяет максимально сократить размеры готовых сборок. Минус в том, что многоступенчатую сборку сложнее
 * поддерживать.
 *
 * Файл .dockerignore.
 * Эти файлы похожи на .gitignore. То есть, если в файле .dockerignore встретится шаблон *.jpg, то при создании образа
 * будут проигнорированы все файлы с расширением .jpg. Если в файле .dockerignore встретится строка videos, то система
 * проигнорирует папку videos и все ее содержимое. При составлении файла .dockerignore, его можно снабжать комментариями
 * с помощью символа #. В чем преимущества использования .dockerignore:
 *      - Это позволяет исключать из состава образа файлы, содержащие секретные сведения, такие как логины и пароли.
 *      - Это позволяет уменьшить размер образа. Чем меньше в образе файлов - тем меньше будет его размер и тем быстрее
 *              с ним можно будет работать.
 *      - Это дает возможность чаще использовать кэш. Например, если при повторной сборке образа меняются некие
 *              служебные файлы проекта, из-за чего данные, хранящиеся в кэше, необоснованно признаются
 *              недействительными, это замедляет сборку образов
 *
 * */

package docker;

public class L4 {
}
