/**
 *
 *                                          Отличия между Java IO и Java NIO.
 * IO:
 *  - Потокоориентированный
 *  - Блокирующий(синхронный) ввод/вывод
 * NIO:
 *  - Буфер-ориентированный
 *  - Неблокирующий(асинхронный) ввод/вывод
 *  - Селекторы
 *
 * Потокоориентированный и буфер-ориентированный ввод/вывод.
 * Основное отличие между двумя подходами к организации ИО в том, что Java IO является потокоориентированным, а Java NIO
 * - буфер-ориентированным. Что это значит.
 * Потокоориентированный ИО подразумевает чтение/запись из потока/в поток одного или нескольких байт в единицу времени
 * поочередно. Данная информация нигде не кэшируется. Таким образом, невозможно произвольно двигаться по потоку данных
 * вперед или назад. Если мы захотим произвести подобные манипуляции, нам придется сначала кэшировать данные в буфере.
 * Потокоориентированный ввод - рис io_1.png, потокоориентированный вывод - io_2.png
 * Подход, на котором основан Java NIO немного отличается. Данные считываются в буфер для последующей обработки. Мы можем
 * двигаться по буфера взад и вперед. Этот подход дает нам больше гибкости, но нам нужно проверять, содержит ли буфер
 * необходимый для корректной обработки объем данных. Кроме того, нужно следить, чтобы при чтении данных в буфер, мы не
 * уничтожили еще не обработанные данные, находящиеся в буфере.
 *
 * Блокирующий/неблокирующий ИО.
 * Стримы Java IO являеются блокирующими. Это значит, что, когда в потоке исполнения (thread) вызывается read() или
 * write() метод из любого класса java.io.* происходит блокировка потока исполнения до тех пор, пока данные не будут
 * полностью считаны или записаны. Поток исполнения в этот момент не может делать ничего другого.
 * Неблокирующий режим Java NIO позволяет запрашивать считанные данные из канала(channel) и получать только то, что
 * доступно на данный момент, или вообще ничего, если доступных данных пока нет. Вместо того, чтобы оставаться заблокированным
 * пока данные не станут доступными, поток может заняться чем-нибудь другим. Тоже самое можно сказать и о неблокирующем
 * выводе данных.
 * Каналы - это логические(не физические) порталы, через которые осуществляется ИО данных, а буферы являются источниками
 * или приемниками этих переданных данных. При выводе, данные, которые мы хотим отправить помещаются в буфер, а уже буфер
 * передается в канал. При вводе, данные наоборот, из канала помещаются в буфер. Каналы напоминают трубопроводы, по
 * которым транспортируются данные между буферами байтов и сущностями по ту сторону каналов. Каналы - это шлюзы, которые
 * позволяют получить доступ к сервисам ИО операционной системы с минимальными накладными расходами, а буферы - это
 * внутренние точки этих шлюзов, исползуемые для передачи и приема данных.
 * Таким образом, неблокирующий режим Java NIO позволяет использовать один поток выполнения для решения нескольких задач
 * вместо пустого прожигания времени на ожидание в заблокированном состоянии.
 * Селекторы - рис selector.png.
 * Селекторы в Java NIO позволяют одному потоку выполнения мониторить несколько каналов. Мы можем зарегистрировать
 * несколько каналов для одного селектора, а поток использовать один поток исполнения для обслуживания этих каналов.
 * Это может быть обработка доступных данных, выбор канала, готового для записи, и т д. Чтобы лучше понять концепцию и
 * выгоду от применения селекторов - абстрагируемся от программирования и представим себе ЖД вокзал. Вариант без селектора:
 * есть три жд пути(каналы), на кжадый из них в любой момент может прибыть поезд(данные из буфера), на каждом пути постоянно
 * ожидает сотрудник вокзала(поток исполнения), задача которого - обслуживание прибывшего поезда. В рещультате - трое
 * сотрудников вокзала постоянно находятся на вокзале, даже если там вообще нет поездов. Вариант с селектором: ситуация
 * та же, но для каждой платформы есть индикатор, сигнализирующий сотруднику вокзала(потоку исполнения) о прибытии поезда.
 * Таким образом, на вокзале достаточно присутствия одного сотрудника.
 *
 * */

package habr.io_nio;

public class DifferenceIOandNIO {
}
