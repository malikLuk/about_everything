/**
 *
 * В предыдущей статье поведение сервера было простым - он получал запрос от клиента, обрабатывал его, обновлял состояние игры и
 * отправлял результат обратно на клиент. Но когда клиентов много и они часто отправляют команды, обновление мира для каждой из них
 * и оповещение каждого клиента об изменении состояния сильно нагружало бы сеть и процессор. Более удачный подход - накапливать
 * команды, не выполняя их. А потом обрабатывать все накопившиеся команды (тут же можно обработать физику для более плавной её работы)
 * с некоторой периодичностью, например, 10 раз в секунду и рассылать новое состояние всем клиентам. Пример в "10 раз в секунду" взять
 * от потолка, можно (и нужно) больше. Коротко говоря, у игрового мира есть собственная фиксированная частота обновления, не зависящая
 * от наличия команд и их количества.
 * Пока игрок один - для него все ок, но ему слишко редко приходят обновления о том, что происходит с другими игроками: клиент применяет
 * обновление состояния другого игрока, как только получает. Размеется, это ведет к рывкам из-за ненадежности сетей, да и предсказание
 * анимации для другого игрока сделать не получится (scheme_2_0.png, scheme_2_1.png - тут видно, что для игрока_1 игрок_2 движется рывками
 * и наоборот, для игрока_2 рывками движется игрок_1).
 * Экстраполяция (распространение выводов, полученных от наблюдения над одной частью явления, на другую его частью).
 * Предположим, мы делаем гонки. Если машина едет 100 м/с, то через секунду она будет примерно на 100 метров впереди от того места, где
 * она была. "Примерно", потому что за эту секунду машина могла немного затормозить/ускориться/повернуть и т д. Ключевое слово здесь
 * "немного". Актуальная позиция машины преимущественно зависит от предыдущей позиции, скорости и направления - другими словами, она не
 * может мгновенно развернуться на 180 градусов. Если мы получаем обнволения каждые 100 м/с, то самое простое - это предположить, что
 * направление и ускорение будут константными в течение этих 100 м/с и локально воспроизводить физику машины с учетом этих параметров.
 * Позже, когда обновления от сервера придут - позиция машины будет скорректирована. Этот метод подойдет для объектов с большой инерцией,
 * которые не могут резко менять направление, например, машины или корабли.
 * Интерполяция (нахождение неизвестных промежуточных значений, по уже известному набору ее значений).
 * В 3d шутере направление и скорость объектов меняется быстро - экстраполяция неприменима. Тут нельзя наивно применять простые обновления
 * каждые X м/с, так как игроки будут телепортироваться каждый раз при потерянном/задерживающемся пакете. Допустим, у нас есть информация
 * о позиции игроков каждые 100 м/с. Трюк заключается в том, чтобы показывать игроку, что происходило между этими обновлениями в прошлом.
 * То есть, мы получаем позиции в момент t = 1000. У нас уже есть инфомрация о том, что происходило в t = 900, так что от t = 1000 до t = 1100
 * мы показываем что игрок делал с t = 900 до t = 1000. Таким образом, мы показываем настоящее перемещение врагов, но на 100 м/с позже. См.
 * scheme_2_2.png и scheme_2_3.gif. Нужно учесть, что при использовании интерполяции, игроки видят немного разное состояние мира: сам игрок
 * видит свое актуальное состояние (чтобы не было лага при вводе), а врагов видит чуть-чуть в прошлом. В принципе, при малых промеждутках
 * обновлений - все ок. Но если нужна высокая пространственная и временная точность, например, при выстреле одного человека вдругого, то не
 * ок. Другие игроки видны с задержкой, то есть в прошлом и целясь во врага сейчас - мы целисмся в то место, где он был 100 м/с назад
 * scheme_2_4.gif.
 *
 * */

package habr.multiplayer;

public class Part2 {
}
