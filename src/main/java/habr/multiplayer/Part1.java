/**
 *
 * Читеры вредят мультиплеер, нельзя просто так доверять сообщениям с клиента - всегда нужно ожидать, что игрок захочет нас обмануть.
 * Авторитарный сервер и наивный клиент - подход, когда вся игровая логика крутится на сервере, а клиент лишь демонстрирует текущее
 * состояние сервера и отправляет ему команды (нажатие клавиш и т д). Авторитарный сервер снимает широкий спектр читов. Например, нельзя
 * доверять уровень жизни игрока клиенту. Взломанный клиент может сказать, что у игрока 10000% хп, но сервер знает, что на самом деле 10%.
 * Также нельзя верить игроку, когда он сообщает о позиции в мире. Если, условно, клиент в один момент времени был на точке (10, 10), а
 * секундой позже уже на (20, 10) - он, возможно, прошел через стену или двигался быстрее, чем ему положено. Вот как это должно быть:
 * сервер знает, что клиент на (10, 10), клиент говорит "Я хочу подвинуться на 1 вправо", сервер обновляет позицию игрока на (11, 10),
 * производя необходимые проверки, а затем отвечает игроку: "Вы на (11, 10)" (scheme.png, scheme1.gif). Такой наивный клиент подходит
 * для неторопливых пошаговых игр - стратегий или покера. Также он неплохо работает при локальном подключении, где информация передается
 * почти мгновенно. Но он абсолютно непригоден для быстрых игр по интернету из-за сложности маршрутов, не лучшей сети и т д. Все факторы
 * в сумме дают нам лаги.
 * Избежать визуальных лагов помогает система предсказаний на стороне клиента. Суть в том, что большинство игроков все таки не читеры и
 * сервер большую часть времени получает корректные запросы - это означает, что скорее всего, полученный ввод корректен и игра обновится
 * так, как ожидается. То есть, если персонаж находится в (10, 10) и отправляет команду на движение вправо, он окажется на (11, 10). Это
 * можно использовать, если игра достаточно детерминирована - то есть результат определен командами и предыдущим состоянием. Предположим,
 * что у нас сетевой лаг в 100 мс и время перемещения персонажа тоже 100 мс. При использовании наивной реализации, время действия будет
 * 200 мс, что очень много (scheme2.png). Предполагая, что команды будут исполнены, клиент может предсказывать состояние игрового мира и
 * часто предсказания будут правильными, т.к. игровой мир детерменированный. То есть, вместо того, чтобы отправлять команду и ждать, пока
 * сервер ее обработает и придет новое состояние, чтобы клиент мог начать его рендерить, мы можем отправить команду и начать рендерить
 * предполагаемый результат, как если бы команда уже была выполнена. И, конечно, надо ждать от сервера "настоящего" получившегося состояния,
 * которое, как правило, будет совпадать с локальным (scheme3.png).
 * Проблемы синхронизации.
 * С лагом 100 мс и анимацией в 100 мс у нас отлично все совпадает. Но  что если лаг будет 250 мс, а анимация передвижения на одну единицу
 * будет составлять 100 мс. А еще игрок дважды нажал вправо. Что произойдет видно на scheme4.png. Мы столкнулись с интересной проблемой на
 * t = 250 мс, когда нам пришло новое состояние. Клиент предсказал, что итоговая координата, после двух нажатий вправо будет (12, 10),
 * но сервер говорит, что (11, 10), но позже на t = 350 мс сервер говорит, что игрок на (12, 10), то есть получится, что персонаж как бы
 * "прыгает" (scheme5.gif). С точки зрения игрока это выглядит так: он нажал кнопку "вправо" дважды, так что персонаж переместился на две
 * еденицы вправо, постоял там 50 мс, прыгнул на еденицу влево, так как пришло состояние от сервра на первое нажатие "вправо", постоял там
 * 100 мс и прыгнул на еденицу вправо, так как пришло состояние от сервера на второе нажатие "вправо".
 * Ключ к решению этой проблемы лежит в согласовании с сервером. Клиент видит игровой мир в настоящем, но из-за лага, обновления с сервера
 * приходят с состоянием мира в прошлом. К тому моменту как сервер отправил клиенту обновления - он еще не получил или не обработал некоторые
 * команды клиента. Обойти это можно с помощью добавления номера последнего обработанного запроса, а также надо хранить на клиенте копию
 * всех команд, отправляемых на сервер. Пример на scheme6.png. Клиент также отправляет 2 команды #1 и #2, сохраняя их у себя. На t = 250
 * клиенту приходит «x = 11, последняя команда #1». Клиент удаляет все команды до #1 включительно, но оставляет копию #2, о которой еще
 * не знает сервер. Он применяет полученное от сервера состояние (x = 11), а затем применяет ввод, который еще не виден серверу. В данном
 * случае #2 «вправо на 1 единицу». Конечный результат x = 12, что соответствует истине. Далее, на t=350, от сервера приходит новое состояние:
 * «x = 12, последняя команда #2». Клиент удаляет все копии команд до #2 включительно, а затем применяет состояние x=12(ничего не изменилось).
 * Так как более нет необработанных команд, на этом все заканчивается, с корректным результатом (scheme7.gif).
 * При использовании авторитарного сервера, мы должны предоставить игроку иллюзию отзывчивости, хотя на самом деле мы ждете пока сервер на
 * самом деле обработает ввод. Для этого клиент симулирует результат всех команд. Когда приходит обновление от сервера, состояние обновляется
 * исходя из текущего состояния сервера и необработанных им команд.
 *
 *
 * */

package habr.multiplayer;

public class Part1 {
}
