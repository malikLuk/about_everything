/**
 *
 * https://habr.com/ru/post/121858/
 * Параллельный доступ к реляционным БД. Рассмотрим ситуацию: нам, в некой учетной системе необходимо отражать изменение
 * остатков товара при проведении документов. Структура бд представлена в optimistic_schema.sql. Допустим, наш документ
 * отвечает за списание товара со склада. Код приложения загружает данные документа и остатка, производит вычисления и
 * сохраняет данные в БД. Если это действие выполняет одно приложение, то все в порядке.
 *
 *      SELECT quantity, processed, stock FROM documents WHERE id = 1;
 *
 *                       quantity | processed | stock
 *                      ----------+-----------+-------
 *                          15.60 | f         |     1
 *
 *      SELECT name, quantity FROM stocks WHERE id = 1;
 *                       name | quantity
 *                      ------+----------
 *                      сыр   |    56.40
 *
 * Загружены данные документа с id = 1 и остатка, соответствующего ему. Вычислено новое значение остатка, путем списания
 * 56,40 - 16,60 = 40,80 и данные сохранены обратно вместе с пометкой об обработке документа.
 *
 *      UPDATE stocks SET quantity = 40.80 WHERE id = 1;
 *      UPDATE documents SET processed = true WHERE id = 1;
 *
 * Но однопользовательские системы - это давнее прошлое, поэтому рассмотрим ситуацию, когда обрабатываются два документа
 * одновременно. Как и в первом случае, приложение считывает данные из базы. Первый пользователь:
 *
 *      SELECT quantity, processed, stock FROM documents WHERE id = 1;
 *
 *                       quantity | processed | stock
 *                      ----------+-----------+-------
 *                          15.60 | f         |     1
 *
 *      SELECT name, quantity FROM stocks WHERE id = 1;
 *                       name | quantity
 *                      ------+----------
 *                      сыр   |    56.40
 *
 * Второй пользователь:
 *
 *      SELECT quantity, processed, stock FROM documents WHERE id = 2;
 *
 *                       quantity | processed | stock
 *                      ----------+-----------+-------
 *                          26.10 | f         |     1
 *
 *      SELECT name, quantity FROM stocks WHERE id = 1;
 *                       name | quantity
 *                      ------+----------
 *                      сыр   |    56.40
 *
 * И тут возникает очевидная проблема: первое приложение вычисляет 56,40 - 16,60 = 40,80, а второе вычисляет
 * 56,40 - 26,10 = 30,30. И в базу запишется любой из этих результатов - а именно тот, для которого будет выполнен
 * последний update запрос. Тут вы встречаемся с состоянием гонок, а именно их разновидностью read-modify-write, когда
 * результирующее состояние является производным от текущего (в данном случае - неверного). И даже если бы мы проверяли
 * поле processed, все равно могла бы произойти ситуация, при которой документ мог быть обработан дважды. Все тоже
 * состояние гонок, но другого вида - check-then-act, когда потенциально устаревшее наблюдение применяется для принятия
 * решения. Чтобы решить эти проблемы нам понадобится понимание таких вещей как транзакции и блокировки.
 * Транзакции и уровни изоляции.
 * Транзакция является единой последовательностью операций по взаимодействию с бд, которая воспринимается как одно
 * целое. Транзакция имеет возможность для отката или подтверждения совершенных операций. Транзакция может являться
 * средством разрешения проблем согласованности изменений, а также не допускать состояния гонок. Пригодность транзакций
 * для решения первой или обоих проблем определяется уровнем изоляции. Изоляция - это свойство, которое, которое
 * определяет как и когда изменения сделанные одной операции будут видны параллельной операции.
 * Стандарт SQL определяет 4 уровня изоляции транзакций: read uncommited, read commited, repeatable read, serializable.
 * Все они отличкаются минимально допустимым уровнем изоляции. Основные свойства понятны из названий. Однако, в Postgres
 * внутренне реализована поддержка только двух уровней изоляции read commited и serializable. По умолчанию postgres
 * использует уровень read commited, что позволяет решить проблему несогласованного состояния данныъ. Это достигается за
 * счет того, что все изменения сделанные внутри транзакции становятся видны параллельным тразакциям после завершения
 * текущей. Примерно, для нашего примера, это выглядит так:
 *
 *      BEGIN;
 *
 *      SELECT quantity, processed, stock FROM documents WHERE id = 1;
 *      SELECT name, quantity FROM stocks WHERE id = 1;
 *      --вычисления в коде приложения
 *      UPDATE stocks SET quantity = 40.80 WHERE id = 1;
 *      UPDATE documents SET processed = true WHERE id = 1;
 *
 *      COMMIT;
 *
 * Но такая транзакция не решает проблему с состоянием гонок при конкурентном выполнении операций. В такой ситуации
 * может помочь другой уровень изоляции - Serializable, однако поведение реализации этого уровня изоляции не в полной
 * мере соответсвует своему названию. То есть транзакции с уровнем изоляции serializable не выполняются последовательно.
 * Вместо этого, при коммите транзакции проверяется конфликт при изменении данных, и если данные уже были изменены
 * параллельной транзакцией - то текущая завершается с ошибкой. Выглядит это, примерно так:
 *
 *      BEGIN ISOLATION LEVEL SERIALIZABLE;
 *
 *      SELECT quantity, processed, stock FROM documents WHERE id = 1;
 *      SELECT name, quantity FROM stocks WHERE id = 1;
 *      --вычисления в коде приложения
 *      UPDATE stocks SET quantity = 40.80 WHERE id = 1;
 *      UPDATE documents SET processed = true WHERE id = 1;
 *
 *      COMMIT;
 *
 * Представленная выше транзакция решает проблему и с состоянием гонок и с согласованностью данных. Код, выполняющий
 * эту транзакцию узнает об успешности только после завершения транзакции. И в результате неудачи необходимо будет
 * повторять все действия и вычисления до тех пор, пока транзакция не завершится успехом или не будет принято решение
 * отказаться от выполнения транзакции вообще. Такой подход очень плох при большой конкурентной нагрузке, потому как
 * болььшое количество ресурсов будет потребляться на выполнение повторов. Подобное поведение называется оптимистическим
 * параллельным контролем (optimistic concurrency control).
 *
 * Блокировки.
 * В postgres реализована поддержка множества типов блокировок, которые могут конфликтовать между собой. Это означает,
 * что текущая блокировка не может быть захвачена совместно с блоикровками любого из конфликтующих типов. Вдобавок,
 * блокировки делятся на явные и неявные. Явные выполяются в запросе с помощью ключевого слова lock и модификаторов
 * for update или for share, другими словами - явные блокировки указываются пользователем. Неявные блокировки - это те,
 * которые захватываются при выполнении различных запросов (select, update, insert, alter и прочие). Postgres также
 * поддержвиет отдельный вид блокировок, которые называют рекомендательными (advisory lock). Блокировки захватываются с
 * момента выполнения запроса и до конца транзакции. Например, в нашей учетной системе можно было захватить эксклюзивную
 * блокировку на строку таблицы stocks соответствующей остатку, с которым выполняется операция (в нашем случае - сыр) и
 * на строку таблицы documents, тем самым гарантировать, что только текущая транзакция имеет доступ к этим данным.
 *
 *      BEGIN;
 *
 *      SELECT quantity, processed, stock FROM documents WHERE id = 1 FOR UPDATE;
 *      SELECT name, quantity FROM stocks WHERE id = 1 FOR UPDATE;
 *      --вычисления в коде приложения
 *      UPDATE stocks SET quantity = 40.80 WHERE id = 1;
 *      UPDATE documents SET processed = true WHERE id = 1;
 *
 *      COMMIT;
 *
 * В примере выше мы захватили строки таблиц stocks и documents на обновление (for update). При попытке захватить
 * блокировку на области, на которой уже захвачена блокировка, происходит блокирование запроса (по умолчанию) до тех
 * пор, пока блокировка не освободится, либо, если дедлок - то ошибка. Есть возможность устанавливать интервал
 * возвращения управления из блокированного запроса, либо сразу сообщать о невозможности захвата блокировки.
 *
 * Виды параллельного контроля.
 * Оптимистический параллельный контроль предполагает проверку возможного конфликта при совершении действия. Например,
 * пользователь запрашивает некоторые данные из хранилища и изменяет их, после чего пытается сохранить свои изменения.
 * Если текущая версия данных, находящаяся в хранилище соответствует версии данных, на основе которых происходили
 * изменения, то конфликт отсутствует и данные могут быть сохранены. В обратном случае - конфликт и мы либо повторяем
 * действие, либо отказываемся от него. Обеспечивает хорошую производительность.
 *
 * Пессимистический параллельный контроль предполагает проверку возможного конфликта перед выполнением действия. То есть
 * параллельные потоки сериализуются на защищаемой области(выстраиваются в очередь).
 *
 * Частично-оптимистический - смешанный тип. Применяются оба подхода одновременно.
 *
 * В статье еще есть примеры кода шаблона Unit of Work.
 *
 * */

package habr.optimistic_lock;

public class Main {
}
