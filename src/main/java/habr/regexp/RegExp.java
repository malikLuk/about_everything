/**
 * Pattern, Matcher. Регулярные выражения.
 * https://habr.com/ru/post/260773/
 * Регулярные выражения в Java используют механизм НКА(недетерменированный конечный автомат). Суть его в том, что НКА
 * проверяет регулярное выражение покомпонентно и проверяет, совпадает ли каждый конкретный компонент с текстом. Если
 * совпадает - проверяет следующий компонент. Процедура повторяется до тех пор, пока не будет найдено совпадение всех
 * компонентов регулярного выражения(пока не получим общее совпадение).
 * В ЯП существует три подхода к обработке регулярных выражений:
 * 1. Интегрированный - встраивание рег выражений в низкоуровневый синтаксис языка. Этот подход упрощает работу
 * программиста.
 * 2. Процедурный.
 * 3. Объектно-ориентированный - функциональность(как и в процедурном подходе) обеспечивают функции и методы, которые
 * принимают в качаетсве параметров строки(вместо спец. конструкций языка) и интерпритируют их как регулярные
 * выражения.
 * В Java используется ОО-подход. Для работы с регулярками в Java есть пакет java.util.regex. пакет был добавлен в версии
 * 1.4. Все функциональные возможности представлены двумя классами(Matcher, Pattern), интерфейсом(MatchResult) и одним
 * исключением(PatternSyntaxException) рис 1.png.
 * Pattern
 * Класс Pattern представляет собой скомпилированное представление регулярных выражений. Класс не имеет открытых
 * конструкторов, поэтому для создания инстанса нужно вызвать статический метод compile и передать строку с регулярным
 * выражением в качестве первого аргумента:
 * // XML тэг в формате <xxx></xxx>
 * Pattern pattern = Pattern.compile("^<([a-z]+)([^>]+)*(?:>(.*)<\\/\\1>|\\s+\\/>)$");
 * Также в качестве второго параметра в метод compile можно передать флаг в виде статической константы класса Pattern:
 * // email адрес в формате xxx@xxx.xxx (регистр букв игнорируется)
 * Pattern pattern = Pattern.compile("^([a-z0-9_\\.-]+)@([a-z0-9_\\.-]+)\\.([a-z\\.]{2,6})$", Pattern.CASE_INSENSITIVE);
 * Таблица всех ддоступных констант и эквивалентных им флагов представлена на рисунке 2.png
 * С помощью метода matches мы можем проверить вхождение подстроки(в виде регулярного выражения) в строку:
 * // проверяет является ли подстрока hex-кодом цвета
 * Pattern.matches("^#?([a-f0-9]{6}|[a-f0-9]{3})$", "#8b2323"); true/false
 * Либо мы можем разделить строку используя регулярное выражение:
 * // Разбиваем строку по двоеточию или точке-запятой
 * Pattern pattern = Pattern.compile(":|;");
 * String[] animals = pattern.split("cat:dog;bird:cow");
 * Arrays.asList(animals).forEach(animal -> System.out.print(animal + " "));
 * Matcher и MatchResult.
 * Класс, который представляет строку, реализует механизм согласования(matching) с регулярным выражением и хранит результаты
 * этого согласования(используя реализацию методов интерфейса MatchResult). не имеет открытых конструкторов- для создания
 * объекта используется Pattern.matcher(str);
 * // будем искать URL
 * String regexp = "^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$";
 * String url = "http://habrahabr.ru/post/260767/";
 * Pattern pattern = Pattern.compile(regexp);
 * Matcher matcher = pattern.matcher(url);
 * Однако, результатов у нас нет. Чтобы их получить, нужно воспользоваться методом find. Можно также использовать matches(),
 * который вернет true только тогда, когда вся строка соответствует заданному регулярному выражению, в отличии от find,
 * который ищет подстроку, уоторая будет удовлетворять регулярному выражению. Сравнение работы find() и matches() на
 * рисунке 3.png
 */

package habr.regexp;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegExp {

    public static void main(String[] args) {
        // IP адрес
        String regexp = "(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
// для сравнения работы find() и matches()
        String goodIp = "192.168.0.3";
        String badIp = "192.168.0.3g";

        Pattern pattern = Pattern.compile(regexp);

        Matcher matcher = pattern.matcher(goodIp);
// matches() - true, find() - true
        matcher = pattern.matcher(badIp);
// matches() - false, find() - true

// а теперь получим дополнительную информацию
        System.out.println(matcher.find() ?
                "I found '" + matcher.group() + "' starting at index " + matcher.start() + " and ending at index " + matcher.end() + "." :
                "I found nothing!");
// I found the text '192.168.0.3' starting at index 0 and ending at index 11.
    }

}
