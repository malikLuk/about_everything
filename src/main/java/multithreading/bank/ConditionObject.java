/**
 *
 *                                                      Объекты условий.
 * Нередко случается так, что поток входит в критический раздел кода только для того, чтобы обнаружить, что он не может
 * продолжить свое выполнение до тех пор, пока не будет соблюдено определенное условие. В подобных случаях для управления
 * потоками, которые захватили блокировку, но не могут выполнить полезные действия, служит ОБЪЕКТ УСЛОВИЯ. Также их называют
 * условными переменными. Модифицируем наш симулятор банка - запретим перемещение денег со счета, но код, подобный
 * следующему, для нас не годится:
 * if (bank.getBalance(from) >= amount) {
 *      // в этом месте, после прохождения проверки на балансе уже может быть сумма, меньше нужной
 *      // или поток вообще может быть деактивирован надолго
 *     bank.transfer(from, to, amount);
 * }
 * Чтобы избежать этого, нужно защитить как проверку остатка, так и сам перевод с помощью следующей блокировки:
 * public void transfer(int from, int to, int amount) {
 *     bankLock.lock();
 *     try {
 *         while (accounts[from] < amount) {
 *             // ожидать
 *         }
 *         // перевести деньги
 *     } finally {
 *         bankLock.unlock();
 *     }
 * }
 * Что делать дальше, если на счете нет достаточной суммы? Ожидать до тех пор, пока счет не будет пополнен в каком-то
 * другом потоке? Но ведь данный поток только что получил монопольный доступ к объекту bankLock, так что ни в одном другом
 * потоке нет возможности пополнить счет. И здесь на помощь приходит объект условия. С объектом блокировки может быть
 * связан один или несколько объектов условий, которые получены с помощью метода newCondition(). Напрмер:
 * class Bank {
 *     private Condition sufficientFunds; //достаточно средств
 *
 *     public Bank() {
 *         ...
 *         sufficientFunds = bankLock.newCondition();
 *     }
 * }
 * Если в методе transfer() будет обнаружено, что средств на счете недостаточно, он сделает следующий вызов:
 * sufficientFunds.await();
 * Это значит, что текущий поток теперь деактивирован и снимает блокировку. Это дает возможность пополнить счет в другом
 * потоке. Когда перевод денег в другом потоке будет произведен, в нем должен быть сделан следующий вызов:
 * sufficientFunds.signalAll();
 * При этом вызове активизируются все потоки, ожидающие данного условия, то есть все, где был вызван await(). В общей
 * форме это выглядит так:
 * while (!some_condition) {
 *     lockCondition.await();
 * }
 * Метод signalAll() активизирует ВСЕ ожидающие потоки, чтобы они могли соперничать за объект блокировки. Другой метод
 * signal() разблокирует только один поток из набора ожидания, выбрав его случайным образом. Это, в принципе, хороший
 * вариант, кроме того момента, что если случайно выбранный поток обнаружит, что не может продолжить свое выполнение,
 * он вновь заблокируется. И есл другой поток снова не вызовет signal(), то система перейдет в состояние дедлока.
 * Смотреть обновленный класс Bank.
 * Страница 782.
 *
 * */

package multithreading.bank;

public class ConditionObject {
}
