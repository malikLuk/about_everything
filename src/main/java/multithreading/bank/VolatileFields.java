/**
 *
 *                                              Поля volatile.
 * Плата за синхронизацию кажется порой непомерной, когда нужно просто считать или записать данные в одно или два поля
 * объекта. К сожалению, так надо, так как современные компиляторы оставляют широкие возможности для появления ошибок.
 *  - Компьютеры с несколькими процессорами могут временно удерживать значения из памяти в регистрах или локальных кэшах.
 *      Вследствие этого, потокам, выполняющимся на разных процессорах, могут быть доступны разные значения одной и той
 *      же переменной, из одной и той же области памяти.
 *  - Компиляторы могут изменять порядок выполнения команд для достижения максимальной производительности. Смысл кода не
 *      меняется.
 * Если мы пользуемся блокировками для защиты кода, который может выполняться в нескольких потоках, то вряд ли столкнемся
 * с подобными затруднениями. Компиляторы обязаны соблюдать блокировки, очищая при необходимости локальные кэши и не изменяя
 * порядок следования команд. Поднобнее см JSR 133. Если проще, то если мы записываем значение в переменную, которая может
 * быть прочитана в другом потоке, или читаем переменную, которая могла быть записана в другом потоке, то нужно использовать
 * синхронизацию. Но бывает так, что нам нужно просто, чтобы компилятор имел ввиду, что поле может быть изменено. Тогда
 * записываем его как volatile. Теперь при выполнении JVM за этим полем будет ходить в ОЗУ, а не читать из регистров.
 * Volatile - это что-то вроде упрощенной синхронизации, они НЕ гарантируют никакой атомарности операций!!! Можно также
 * объявить поля final.
 *
 * */

package multithreading.bank;

public class VolatileFields {
}
