/**
 *
 *                                                Ключевое слово synchronized.
 * Краткие итоги предыдущих разделов:
 *  - блокировка защищает критические разделы кода, позволяя выполнять этот код только одному потоку в единицу времени.
 *  - блокировка управляет потоками, которые пытаются войти в защищенный раздел кода.
 *  - Каждый объект условия управляет потоками, которые вошли в защищенный раздел кода, но пока еще не в состоянии
 *          продолжить свое выполнение.
 * Интерфейсы Lock и Condition предоставляют программистам высокую степень контроля над блокировками. Но зачастую такой
 * контроль не требуется, и оказывается достаточно механизма, встроенного в Java. Еще со времен Java 1.0 КАЖДЫЙ объект
 * в Java обладает встроенной блокировкой. Если метод объявлен с ключевым словом synchronized, то блокировка объекта
 * защищает весь этот метод. Следовательно, поток должен захватить встроенную блокировку объекта, чтобы вызвать такой
 * метод. Иными словами, следующий фрагмент кода:
 * public synchronized void method() {
 *     // some code
 * }
 * равнозначен этому:
 * public void method() {
 *     this.someLock.lock();
 *     try {
 *         // some code
 *     } finally {
 *         this.someLock.unlock();
 *     }
 * }
 * Например, вместо явной блокировки можно просто объявить метод transfer() из класса Bank как synchronized. Встроенная
 * блокировка объектов имеет единственное связанное с ней условие. Метод wait() вводит поток в набор ожидания, а методы
 * notify()/notifyAll() разблокируют ожидающие потоки. То есть, вызов wait() или notifyAll() равнозначен:
 * condition.await();
 * condition.signalAll();
 * Например, метод transfer() из класса Bank можно реализовать следующим образом:
 *  public synchronized void transfer(int from, int to, int amount) {
 *       while (accounts[from] < amount) {
 *           wait();
 *       }
 *       accounts[from] -= amount;
 *       accounts[from] += amount;
 *       notifyAll();
 *  }
 * и
 *  public synchronized double getTotalBalance() {...}
 *
 * Статичекие методы тоже можно синхронизировать. Но когда вызывается такой метод, он захватывает блокировку не конкретного
 * объекта, а объекта самого класса. То есть, если в классе Bank имеется статический синхронизированный метод, то при его
 * вызове захватывается блокировка объекта Bank.class. В результате, к этому объекту не может обратиться никакой другой
 * поток и никакой другой синхронизированный статический метод того же класса.
 * Встроенным блокировкам и условиям присущи некоторые ограничения, в том числе и приведенные ниже:
 *  - нельзя прервать поток, который пытается захватить блокировку
 *  - нельзя указать время ожидания, пытаясь захватить встроенную блокировку
 * Лучше всего не пользоваться ни объектами типа Lock/Condition, ни ключевым словом synchronized. Зачастую, вместо этого,
 * можно выбрать уже готовый механизм из пакета java.util.concurrent.*, который организует блокировку автоматически. Например,
 * в разделе "Блокирующие очереди" будет показано, как пользоваться очередями для синхронизации потоков, выполняющую общую
 * задачу.
 *
 * */

package multithreading.bank;

public class Synchronized {
}
