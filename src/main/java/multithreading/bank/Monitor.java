/**
 *
 *                                                  Принцип монитора.
 * Мониторы нужны для избежания явных блокировок. Концептуально монитор обладает следующими свойствами:
 *  - Это класс, имеющий только закрытые поля.
 *  - У каждого объекта такого класса имеется связанная с ним блокировка.
 *  - Все методы блокируются этой блокировкой. То есть, если клиент вызывает метод obj.method(), блокировка объекта obj
 *          автоматичеки захватывается в начале этого метода и снимается по его завершении. А поскольку все поля класса
 *          монитора закрытые, то такой подход гарантирует, что к ним нельзя будет обратиться ни в одном из потоков до
 *          тех пор, пока ими манипулирует какой-то другой поток.
 *  - У блокировки может быть любое количество связанных с ней условий.
 * Ранние версии мониторов имели единственное условие с довольно изящным синтаксисом. Так, можно было просто сделать
 * вызов await accounts[from] >= balance, не указывая условную переменную. Но это было непроизводительно. Создатели Java
 * слишком вольно адаптировали принцип Монитора, в результате чего КАЖДЫЙ объект в Java обладает встроенной блокировкой
 * и встроенным условием. Если метод объявлен с ключевым словом synchronized, он действует как метод монитора. Переменная
 * условия доступна через вызовы методов wait(), notifyAll(), notify(). Но объекты в Java отличаются от Мониторов в трех
 * важных отношениях, нарушающих безопасность.
 *  - В Java поля могут быть не только private
 *  - Методы не обязаны быть synchronized
 *  - Встреонная блокировка доступна клиентам
 *
 * */

package multithreading.bank;

public class Monitor {
}
