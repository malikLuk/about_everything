/**
 * Многозадачность бывает кооперативная и вытесняющая.
 * Кооперативная - тип многозадачности, когда поток(или задача) освобождает процессор тогда, когда сам решит. Все остальные
 * потоки(задачи) ждут. При кооперативной многозадачности приложение может захватить столько процессорного времени, сколько
 * посчитает нужным. Все приложения делят между собой процессорное время, переодически передавая управление друг другу.
 * Основной минус - если одно приложение рухнуло с ошибкой, все остальные тоже работать не будут, так как из основной
 * задачи не будет вызова функции "отдать процессорное время следующему".
 * Вытесняющая - это вид многозадачности при котором ОС сама принимает решение о переключении между задачами по истечении
 * некоего кванта времени. Решения принимаются в соотвествии с приоритетами задач. В отличие от Кооперативной многозадачности,
 * управление операционной системе, для перераспределения процессорного времени, передается все зависимости от состояния
 * работающих приложений, благодаря чем, зависшие или зациклившиеся приложения не вешают ОС. Именно вытесняющая модель
 * многозадачности используется в совеременных ОС.
 * Thread.join() говорит потоку, в котором он вызван, ждать завершения потока, для которого он вызван. То есть, если у нас
 * есть поток t1, который выполняет какие-то инструкции и есть поток main, которому надо воспользоваться результтатами
 * работы потока t1, то, вызывая в коде потока main метод t1.join() мы говорим потоку main ждать, пока t1 не выполнит свои
 * инструкции.
 * Из депрекейтед методов - suspend(), который приостанавливает работу потока. Не рекомендован он потому, что может
 * приостановить поток в неоднозначном состоянии. В этом плане sleep() намного лучше, так как это статический метод и
 * вызывается он ИЗ самого потока (Thread.sleep(1000)), в то время как suspend() вызывается ДЛЯ потока (t1.suspend()) и
 * вне его. Вместо методов suspend() и resume() можно воспользоваться методами park() и unpark() класса LockSupport. И то
 * очень осторожно.
 *
 */

package multithreading.youtube;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class Threading {

    static volatile int k = 1;

    public static void main(String[] args) throws InterruptedException {

        /**
         * Пример join'a
         * */
        Thread t1 = new Thread(() -> {
            System.out.println("start t1");
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            k = 1488;
            System.out.println("end t1");
        });

        Thread t2 = new Thread(() -> {
            System.out.println("start t2");
            try {
                t1.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(k);
            System.out.println("end t2");
        });

        t2.start();
        t1.start();

        /**
         * Пример состояния гонки
         * Два потока пишут в один и тот же список и
         * с большой вероятностью перетирают изменения
         * друг друга
         * */
        List<Integer> l1 = Arrays.asList(1,5,9);
        List<Integer> l2 = Arrays.asList(2,8,15);
        List<Integer> res = new ArrayList<>();

        Thread run1 = new Thread(() -> {
            res.add(l1.get(1));
            System.out.println(l1.get(1));
        });

        Thread run2 = new Thread(() -> {
            res.add(l2.get(1));
            System.out.println(l2.get(1));
        });

        run1.start();
        run2.start();
        System.out.println(res.get(0) + " " + res.get(1));

    }

}
