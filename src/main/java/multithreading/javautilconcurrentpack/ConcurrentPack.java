/**
 *
 * Схематично можно поделить пакет java.util.concurrent на модули с рисунка 1.png.
 * Concurrent Collections - набор коллекций, которые наиболее эффективно работают в многопоточной среде, нежели
 * стандартные коллекции из java.util пакета. Вместо базовой обертки Collections.synchronizedList с блокированием
 * доступа ко всей коллекции, используются блокировки по сегментам данных или же оптимизируется работа для параллельного
 * чтения данных по **wait-free алгоритмам**
 *      Неблокирующая синхронизация - подход в параллельном программировании, в котором принят отказ от примитивов
 *      блокировки, таких как семафоры, мьютексы и события. Разделение доступа между потоками идет за счет атомарных
 *      операций и специальных, разработанных под конкретную задачу механизмов блокировки. Есть три уровня неблокирующей
 *      синхронизации:
 *          - Без препятствий (obstruction-free) - самая слабая из гарантий. Поток совершает прогресс в выполнении, если
 *                  не встречает препятствий со стороны других потоков. При этом поток, запущенный в любой момент,
 *                  должен завершить свою работу за определенное количество шагов. Синхронизация с помощью мьютексов не
 *                  отвечает даже этому требованию: если поток, захвативший мьютекс, остановится, все остальные потоки,
 *                  которым этот мьютекс нужен - будут простаивать.
 *          - Без блокировок (lock-free) - для алгоритмов без блокировок гарантируется прогресс по крайней мере для
 *                  одного потока.
 *          - Без ожидания (wait-free) - самая строгая гарантия прогресса. Алгоритм выполняется без ожидания, если
 *                  каждая операция выполняется за определенное количество шагов, не зависящее от других потоков.
 *
 * Queues - неблокирующие и блокирующие очереди с поддержкой многопоточности. Неблокирующие очереди заточены на скорость
 * и работу без блокировки потоков. Блокирующие очереди используются, когда нужно притормозить потоки "Producer" или
 * "Consumer", например, очередь пуста или переполнена или же нет свободного Consumer'а.
 *
 * Synchronizers - утилиты для синхронизации потоков.
 *
 * Executors - содержит в себе отличные фреймворки для создания пулов потоков, планирования работы асинхронных задача с
 * получением результатов.
 *
 * Locks - представляет собой альтернативные и более гибкие механизмы синхронизации потоков по сравнению с базовыми
 * synchronized, wait, notify, notifyAll.
 *
 * Atomics - классы с поддержкой атомарных операций над примитивами и ссылками.
 *
 * 1. Concurrent Collections.
 *                                  CopyOnWrite коллекции.
 * Название говорит само за себя. Все операции по изменению коллекции (add, set, remove) приводят к созданию новой копии
 * внутреннего массива. Тем самым гарантируется, что при проходе итератором по коллекции не кинется
 * ConcurrentModificationException. Следует помнить, что при копировании массива копируются только ссылки на объекты,
 * так что доступ к полям элементов массива НЕПОТОКОБЕЗОПАСЕН. CopyOnWrite коллекции удобно использовать, когда write
 * операции довольно редки, например при реализации механизма подписки listeners. К таким коллекциям относятся:
 *      - CopyOnWriteArrayList<E> - потокобезопасный аналог ArrayList, реализованный с CopyOnWrite алгоритмом.
 *      - CopyOnWriteArraySet<E> - реализация интерфейса Set, использующая за основу CopyOnWriteArrayList.
 *                                  Scalable Maps.
 * Рисунок 2.png. Это улучшенные реализации HashMap и TreeMap с лучшей поддержкой многопоточности и масштабируемости.
 *      - ConcurrentMap<K, V> - интерфейс, расширяющий Map несколькими дополнительными атомарными операциями.
 *      - ConcurrentHashMap<K, V> - В отличие от Hashtable(прошлая потокобезопасная реализация хэш-таблицы) и блоков
 *              synchronized на HashMap, данные здесь представлены в виде сегментов, разбитых по хэшам ключей. В
 *              результате, доступ к данным лочится по сегменту, а не по одному объекту. Разобрать детально.
 *
 * */

package multithreading.javautilconcurrentpack;

public class ConcurrentPack {
}
