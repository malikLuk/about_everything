/**
 *
 * Схематично можно поделить пакет java.util.concurrent на модули с рисунка 1.png.
 * Concurrent Collections - набор коллекций, которые наиболее эффективно работают в многопоточной среде, нежели
 * стандартные коллекции из java.util пакета. Вместо базовой обертки Collections.synchronizedList с блокированием
 * доступа ко всей коллекции, используются блокировки по сегментам данных или же оптимизируется работа для параллельного
 * чтения данных по **wait-free алгоритмам**
 *      Неблокирующая синхронизация - подход в параллельном программировании, в котором принят отказ от примитивов
 *      блокировки, таких как семафоры, мьютексы и события. Разделение доступа между потоками идет за счет атомарных
 *      операций и специальных, разработанных под конкретную задачу механизмов блокировки. Есть три уровня неблокирующей
 *      синхронизации:
 *          - Без препятствий (obstruction-free) - самая слабая из гарантий. Поток совершает прогресс в выполнении, если
 *                  не встречает препятствий со стороны других потоков. При этом поток, запущенный в любой момент,
 *                  должен завершить свою работу за определенное количество шагов. Синхронизация с помощью мьютексов не
 *                  отвечает даже этому требованию: если поток, захвативший мьютекс, остановится, все остальные потоки,
 *                  которым этот мьютекс нужен - будут простаивать.
 *          - Без блокировок (lock-free) - для алгоритмов без блокировок гарантируется прогресс по крайней мере для
 *                  одного потока.
 *          - Без ожидания (wait-free) - самая строгая гарантия прогресса. Алгоритм выполняется без ожидания, если
 *                  каждая операция выполняется за определенное количество шагов, не зависящее от других потоков.
 *
 * Queues - неблокирующие и блокирующие очереди с поддержкой многопоточности. Неблокирующие очереди заточены на скорость
 * и работу без блокировки потоков. Блокирующие очереди используются, когда нужно притормозить потоки "Producer" или
 * "Consumer", например, очередь пуста или переполнена или же нет свободного Consumer'а.
 *
 * Synchronizers - утилиты для синхронизации потоков.
 *
 * Executors - содержит в себе отличные фреймворки для создания пулов потоков, планирования работы асинхронных задача с
 * получением результатов.
 *
 * Locks - представляет собой альтернативные и более гибкие механизмы синхронизации потоков по сравнению с базовыми
 * synchronized, wait, notify, notifyAll.
 *
 * Atomics - классы с поддержкой атомарных операций над примитивами и ссылками.
 *
 * 1. Concurrent Collections.
 *                                  CopyOnWrite коллекции.
 * Название говорит само за себя. Все операции по изменению коллекции (add, set, remove) приводят к созданию новой копии
 * внутреннего массива. Тем самым гарантируется, что при проходе итератором по коллекции не кинется
 * ConcurrentModificationException. Следует помнить, что при копировании массива копируются только ссылки на объекты,
 * так что доступ к полям элементов массива НЕПОТОКОБЕЗОПАСЕН. CopyOnWrite коллекции удобно использовать, когда write
 * операции довольно редки, например при реализации механизма подписки listeners. К таким коллекциям относятся:
 *      - CopyOnWriteArrayList<E> - потокобезопасный аналог ArrayList, реализованный с CopyOnWrite алгоритмом.
 *      - CopyOnWriteArraySet<E> - реализация интерфейса Set, использующая за основу CopyOnWriteArrayList.
 *                                  Scalable Maps.
 * Рисунок 2.png. Это улучшенные реализации HashMap и TreeMap с лучшей поддержкой многопоточности и масштабируемости.
 *      - ConcurrentMap<K, V> - интерфейс, расширяющий Map несколькими дополнительными атомарными операциями.
 *      - ConcurrentHashMap<K, V> - В отличие от Hashtable(прошлая потокобезопасная реализация хэш-таблицы) и блоков
 *              synchronized на HashMap, данные здесь представлены в виде сегментов, разбитых по хэшам ключей. В
 *              результате, доступ к данным лочится по сегменту, а не по одному объекту. Разобрать детально.
 *      - ConcurrentNavigableMap<K,V> - расширяет интерфейс NavigableMap и вынуждает использовать ConcurrentNavigableMap
 *              объекты в качестве возвращаемых значений. Все итераторы декларируются как безопасные к использованию и
 *              не кидают ConcurrentModificationException.
 *      - ConcurrentSkipListMap<K, V> - является аналогом TreeMap с поддержкой многопоточности, данные тоже сортируются
 *              по ключу.
 *      - ConcurrentSkipListSet<E> - реализация интерфейса Set на основе ConcurrentSkipListMap.
 * 2. Queues.
 *                                      Неблокирующие очереди.
 * Потокобезопасные неблокирующие очереди основаны на связных нодах.
 *      - ConcurrentLinkedQueue<E> - в реализации используется wait-free алгоритм. Метод size() может работать долго,
 *              так что лучше лишний раз его не дергать.
 *      - ConcurrentLinkedDeque<E> - Deque расшифровывается как Double ended queue. Это означает, что данные можно
 *              добавлять и вытаскивать с обеих сторон. Соответственно, класс поддерживает и FIFO и LIFO.
 *                                      Блокирующие очереди.
 *      - BlockingQueue<E> - При обработке больших потоков данных через очереди становится явно недостаточно
 *              использования ConcurrentLinkedQueue. Если потоки, разгребающие очередь перестанут справляться с наплывом
 *              данных, то можно быстро получить out of memory. Для таких случаев нужна очередь с возможностью задать
 *              размер очереди или с блокировками по условиям. Тут нам и подходить интерфейс BlockingQueue. Помимо
 *              возможности задать размер очереди, добавились нвоые методы, которые реагируют по-разному на незаполнение
 *              или переполнение очереди. Так, например, при добавлении элемента в переполненную очередь, один метод
 *              кинет IllegalStateException, второй вернет false, третий заблокирует поток, пкоа не появится место
 *              и т.д. Также стоит отметить, что блокирующие очереди не поддерживают null значения, так как это значение
 *              используется в методе poll как  индикатор таймаута.
 *      - ArrayBlockingQueue<E> - класс блокирующей очереди, построенный на классическом кольцевом буфере (структура
 *              данных, в которой, в буфере фиксированного размера, после последнего элемента как будто бы сразу же
 *              снова идет первый). Помимо размера очереди, есть возможность управлять "честностью" блокировок. По
 *              умолчанию fair = false; и очередность потоков не гарантируется.
 *      - LinkedBlockingQueue<E>  - блокирующая очередь на связных нодах, реализованная на "two lock queue" алгоритме:
 *              один лок на добавление, другой на вытаскивание элемента. Там в прямом смысле два лока putLock и
 *              takeLock. За счет двух локов, по сравнению с ArrayBlockingQueue, данный класс показывает более высокую
 *              производительность, но и расход памяти у него выше. Размер очереди заполняется через конструктор и по
 *              умолчанию равен Integer.MAX_VALUE.
 *      - PriorityBlockingQueue<E> - многопоточная обертка над PriorityQueue. При добавлении элемента в очередь, его
 *              порядок определяется в соответствии с логикой Comparator'а или реализации интерфейса Comparable у
 *              элементов. Первым из очереди выходит наименьший элемент.
 *
 * */

package multithreading.javautilconcurrentpack;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ConcurrentPack {

    int a = 0;
    Lock lock = new ReentrantLock();

    public static void main(String[] args) {
        int b = 1;
        System.out.println(++b);
        System.out.println(b);
        ConcurrentPack p = new ConcurrentPack();
        new Thread(() -> {
            try {
                for (int i = 0; i < 10; i++) {
                    Thread.sleep(500);
                    p.incA();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();

        new Thread(() -> {
            try {

                System.out.println(p.getA());
                Thread.sleep(250);
                System.out.println(p.getA());
                Thread.sleep(250);
                System.out.println(p.getA());
                Thread.sleep(250);
                System.out.println(p.getA());
                Thread.sleep(250);
                System.out.println(p.getA());
                Thread.sleep(250);
                System.out.println(p.getA());
                Thread.sleep(250);
                System.out.println(p.getA());
                Thread.sleep(250);
                System.out.println(p.getA());
                Thread.sleep(250);
                System.out.println(p.getA());
                Thread.sleep(250);
                System.out.println(p.getA());
                Thread.sleep(250);
                System.out.println(p.getA());
                Thread.sleep(250);
                System.out.println(p.getA());
                Thread.sleep(250);
                System.out.println(p.getA());
                Thread.sleep(250);
                System.out.println(p.getA());
                Thread.sleep(250);
                System.out.println(p.getA());
                Thread.sleep(250);
                System.out.println(p.getA());

            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
    }

    synchronized void incA() throws InterruptedException {
//        lock.lock();
        Thread.sleep(10000);
        a++;
//        lock.unlock();
    }

    synchronized int getA() {
//        try {
//            lock.lock();
            return a;
//        }
//        finally {
//            lock.unlock();
//        }
    }
}
