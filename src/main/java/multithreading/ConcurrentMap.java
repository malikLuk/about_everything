/**
 *
 *                                          Как работает ConcurrentHashMap.
 *                                                      JDK 1.5
 * 1. В отличие от элементов HashMap, Ноды в ConcurrentHashMap объявлены как volatile:
 *      static class Node<K,V> implements Map.Entry<K,V> {
 *          final int hash;
 *          final K key;
 *          volatile V val;
 *          volatile Node<K,V> next;
 * 2. В ConcurrentHashMap используется улучшенная хэш-функция, засчет чего уменьшена вероятность коллизий.
 * 3. Карта делится на N различных сегментов(по умолчанию 16, максимальное значение 2^16). Каждый сегмент представляет
 *      собой потокобезопасную таблицу элементов карты. Между хэш-кодами ключей и соотвествующими им сегментами устанавливается
 *      заивисмость на основе применения к старшим разрядам хэш-кода битовой маски.
 * 4. ConcurrencyLevel - данный параметр влияет на то, как карта(Map) использует память и количество сегментов в карте.
 *      Очень важно понимать: 1 - занижение concurrencyLevel ведет к тому, что более вероятны блокировки потоками сегментов
 *      карты при записи. Завышение же показателя ведет к неэффективному использованию памяти. Выбрать concurrencyLevel
 *      можно, руководствуясь следующими правилами: если лишь один поток будет изменять карту, а остальные только читать -
 *      тогда ставим зачение 1.
 *
 * */

package multithreading;

public class ConcurrentMap {
}
